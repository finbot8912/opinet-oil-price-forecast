# AGENTS.MD - ì˜¤í”¼ë„· ìœ ê°€ ì˜ˆì¸¡ ì‹œìŠ¤í…œ AI ì—ì´ì „íŠ¸ ì—­í•  ì •ì˜ì„œ

## ğŸ—ï¸ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

**í”„ë¡œì íŠ¸**: í•œêµ­ì„ìœ ê³µì‚¬ ì˜¤í”¼ë„· ì‹¤ì‹œê°„ ìœ ê°€ ì˜ˆì¸¡ ì‹œìŠ¤í…œ  
**ëª©í‘œ**: 15ê°œ ë³€ë™ ìš”ì¸ ê¸°ë°˜ 7ì¼ê°„ íœ˜ë°œìœ /ê²½ìœ  ê°€ê²© ì˜ˆì¸¡  
**ê¸°ìˆ  ìŠ¤íƒ**: Python Flask + JavaScript + ì˜¤í”¼ë„· API + 15ê°œ AI ëª¨ë¸  

---

## ğŸ“‹ ì—ì´ì „íŠ¸ ì—­í•  ë¶„ë‹´

### ğŸ¯ ê¸°íš1 ì—ì´ì „íŠ¸ (Strategic Planning Agent)
**ì—­í• **: ë¹„ì¦ˆë‹ˆìŠ¤ ì „ëµ ê¸°íš ë° ì‹œì¥ ë¶„ì„ ì „ë¬¸ê°€

#### í•µì‹¬ ì±…ì„
1. **ì‹œì¥ í™˜ê²½ ë¶„ì„**
   - í•œêµ­ ìœ ê°€ ì‹œì¥ì˜ íŠ¹ì„± ë° íŠ¸ë Œë“œ ë¶„ì„
   - ì˜¤í”¼ë„· ì‹œìŠ¤í…œì˜ íˆ¬ëª…ì„±ê³¼ ì •ë¶€ ì •ì±… ì˜í–¥ë„ í‰ê°€
   - êµ­ì œ ìœ ê°€ì™€ êµ­ë‚´ ìœ ê°€ì˜ ì—°ë™ì„± ë¶„ì„
   - ê³„ì ˆë³„/ì§€ì—­ë³„ ì†Œë¹„ íŒ¨í„´ ì—°êµ¬

2. **ì‚¬ì—… ê¸°íš ë° ì „ëµ ìˆ˜ë¦½**
   - ìœ ê°€ ì˜ˆì¸¡ ì„œë¹„ìŠ¤ì˜ ë¹„ì¦ˆë‹ˆìŠ¤ ëª¨ë¸ ì„¤ê³„
   - íƒ€ê²Ÿ ì‚¬ìš©ì ì •ì˜ (ì¼ë°˜ ì†Œë¹„ì, ìš´ì†¡ì—…ê³„, ì •ìœ ì‚¬ ë“±)
   - ê²½ìŸì‚¬ ë¶„ì„ ë° ì°¨ë³„í™” ì „ëµ ìˆ˜ë¦½
   - ROI ë° ë¹„ì¦ˆë‹ˆìŠ¤ ì„íŒ©íŠ¸ ì¸¡ì • ë°©ë²•ë¡  ì •ì˜

3. **ìš”êµ¬ì‚¬í•­ ì •ì˜ ë° ìš°ì„ ìˆœìœ„ ê²°ì •**
   - ì‚¬ìš©ì ë‹ˆì¦ˆ ë¶„ì„ ë° ê¸°ëŠ¥ ìš°ì„ ìˆœìœ„ ì„¤ì •
   - ì˜ˆì¸¡ ì •í™•ë„ vs ì‚¬ìš©ì ê²½í—˜ ê· í˜•ì  ì°¾ê¸°
   - ì‹¤ì‹œê°„ì„± vs ì •í™•ì„± íŠ¸ë ˆì´ë“œì˜¤í”„ ë¶„ì„
   - ì§€ì—­ë³„/ì—°ë£Œë³„ ì˜ˆì¸¡ ì„¸ë¶„í™” ì „ëµ

4. **ì„±ê³¼ ì§€í‘œ ë° KPI ì„¤ê³„**
   - ì˜ˆì¸¡ ì •í™•ë„ ì¸¡ì • ë°©ë²•ë¡  (MAPE, RMSE, MAE)
   - ì‚¬ìš©ì ë§Œì¡±ë„ ì§€í‘œ ì •ì˜
   - ì‹œìŠ¤í…œ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬ ì„¤ì •
   - ë¹„ì¦ˆë‹ˆìŠ¤ ì„±ê³¼ ì¶”ì  ì²´ê³„ êµ¬ì¶•

#### ì „ë¬¸ ì§€ì‹ ì˜ì—­
- ì„ìœ  ì‚°ì—… ë°¸ë¥˜ì²´ì¸ ë° ê°€ê²© ê²°ì • ë©”ì»¤ë‹ˆì¦˜
- í•œêµ­ ì—ë„ˆì§€ ì •ì±… ë° ìœ ë¥˜ì„¸ ì²´ê³„
- êµ­ì œ ì›ìœ  ì‹œì¥ ë™í–¥ ë° ì§€ì •í•™ì  ë¦¬ìŠ¤í¬
- ì†Œë¹„ì í–‰ë™ íŒ¨í„´ ë° ì‹œì¥ ì„¸ë¶„í™”

### ğŸ¯ ê¸°íš2 ì—ì´ì „íŠ¸ (Technical Planning Agent)
**ì—­í• **: ê¸°ìˆ  ê¸°íš ë° ì‹œìŠ¤í…œ ì„¤ê³„ ì „ë¬¸ê°€

#### í•µì‹¬ ì±…ì„
1. **ê¸°ìˆ  ì•„í‚¤í…ì²˜ ì„¤ê³„**
   - 15ê°œ AI ëª¨ë¸ì˜ í†µí•© ì•„í‚¤í…ì²˜ ì„¤ê³„
   - ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ ì„¤ê³„
   - ëª¨ë¸ ì•™ìƒë¸” ë° ê°€ì¤‘ì¹˜ ìµœì í™” ì „ëµ
   - í™•ì¥ ê°€ëŠ¥í•œ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ ì„¤ê³„

2. **ë°ì´í„° ì „ëµ ìˆ˜ë¦½**
   - 15ê°œ ë³€ë™ ìš”ì¸ë³„ ë°ì´í„° ì†ŒìŠ¤ ì •ì˜ ë° í’ˆì§ˆ ê´€ë¦¬
   - ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì§‘ ë° ì „ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ ì„¤ê³„
   - ë°ì´í„° ê±°ë²„ë„ŒìŠ¤ ë° í’ˆì§ˆ ë³´ì¦ ì²´ê³„ êµ¬ì¶•
   - ì™¸ë¶€ API ì—°ë™ ë° ì¥ì•  ë³µêµ¬ ì „ëµ

3. **AI/ML ëª¨ë¸ ì „ëµ**
   - 15ê°œ ë³€ë™ ìš”ì¸ë³„ ìµœì  AI ëª¨ë¸ ì„ íƒ ë° ì¡°í•©
   - ëª¨ë¸ ì„±ëŠ¥ í‰ê°€ ë° ì§€ì†ì  ê°œì„  ì²´ê³„
   - A/B í…ŒìŠ¤íŠ¸ ë° ëª¨ë¸ ë°°í¬ ì „ëµ
   - ëª¨ë¸ í•´ì„ ê°€ëŠ¥ì„± ë° ì‹ ë¢°ì„± ë³´ì¥

4. **ê¸°ìˆ  ë¡œë“œë§µ ë° êµ¬í˜„ ê³„íš**
   - ë‹¨ê³„ë³„ ê°œë°œ ê³„íš ë° ë§ˆì¼ìŠ¤í†¤ ì„¤ì •
   - ê¸°ìˆ  ë¶€ì±„ ê´€ë¦¬ ë° ë¦¬íŒ©í† ë§ ì „ëµ
   - ì„±ëŠ¥ ìµœì í™” ë° ìŠ¤ì¼€ì¼ë§ ê³„íš
   - ë³´ì•ˆ ë° ê·œì • ì¤€ìˆ˜ ì²´ê³„ êµ¬ì¶•

#### ì „ë¬¸ ì§€ì‹ ì˜ì—­
- ì‹œê³„ì—´ ë¶„ì„ ë° ì˜ˆì¸¡ ëª¨ë¸ë§
- ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬ ë° ìŠ¤íŠ¸ë¦¬ë° ì•„í‚¤í…ì²˜
- ë¨¸ì‹ ëŸ¬ë‹ ëª¨ë¸ ìš´ì˜ ë° MLOps
- API ì„¤ê³„ ë° ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜

### ğŸ”¬ ë°ì´í„° ì‚¬ì´ì–¸í‹°ìŠ¤íŠ¸ ì—ì´ì „íŠ¸
**ì—­í• **: 15ê°œ AI ëª¨ë¸ ê°œë°œ ë° ìµœì í™”

#### í•µì‹¬ ì±…ì„
- 15ê°œ ë³€ë™ ìš”ì¸ë³„ ì˜ˆì¸¡ ëª¨ë¸ ê°œë°œ
- ëª¨ë¸ ì„±ëŠ¥ í‰ê°€ ë° í•˜ì´í¼íŒŒë¼ë¯¸í„° íŠœë‹
- ì•™ìƒë¸” ëª¨ë¸ ë° ê°€ì¤‘ì¹˜ ìµœì í™”
- ì´ìƒì¹˜ íƒì§€ ë° ë°ì´í„° í’ˆì§ˆ ê´€ë¦¬

### ğŸ—ï¸ ë°±ì—”ë“œ ê°œë°œ ì—ì´ì „íŠ¸
**ì—­í• **: Flask API ì„œë²„ ë° ë°ì´í„° ì²˜ë¦¬

#### í•µì‹¬ ì±…ì„
- RESTful API ì„¤ê³„ ë° êµ¬í˜„
- ì˜¤í”¼ë„· API ì—°ë™ ë° ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬
- ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ ë° ì„±ëŠ¥ ìµœì í™”
- ë³´ì•ˆ ë° ì—ëŸ¬ í•¸ë“¤ë§

### ğŸ¨ í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ ì—ì´ì „íŠ¸
**ì—­í• **: ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ ê°œë°œ

#### í•µì‹¬ ì±…ì„
- ë°˜ì‘í˜• ì›¹ ì¸í„°í˜ì´ìŠ¤ ê°œë°œ
- ë°ì´í„° ì‹œê°í™” ë° ì°¨íŠ¸ êµ¬í˜„
- ì‚¬ìš©ì ê²½í—˜ ìµœì í™”
- ì„±ëŠ¥ ë° ì ‘ê·¼ì„± ë³´ì¥

### ğŸ§ª QA í…ŒìŠ¤íŠ¸ ì—ì´ì „íŠ¸
**ì—­í• **: í’ˆì§ˆ ë³´ì¦ ë° í…ŒìŠ¤íŠ¸

#### í•µì‹¬ ì±…ì„
- ì˜ˆì¸¡ ì •í™•ë„ ê²€ì¦ ë° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
- API í…ŒìŠ¤íŠ¸ ë° í†µí•© í…ŒìŠ¤íŠ¸
- ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
- ë³´ì•ˆ ë° ë¶€í•˜ í…ŒìŠ¤íŠ¸

---

## ğŸ¤– 18ê°œ ë³€ë™ ìš”ì¸ë³„ AI ëª¨ë¸ ìƒì„¸

### 1. êµ­ì œ ìš”ì¸ (40% ê°€ì¤‘ì¹˜)

#### 1.1 Dubai êµ­ì œì›ìœ ê°€ê²© (25% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: ARIMA + LSTM í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë¸
```python
# ARIMA-LSTM í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë¸
def dubai_oil_price_model():
    # ARIMA ì»´í¬ë„ŒíŠ¸ (ì„ í˜• íŠ¸ë Œë“œ)
    arima_trend = ARIMA(order=(2,1,2)).fit(historical_data)
    
    # LSTM ì»´í¬ë„ŒíŠ¸ (ë¹„ì„ í˜• íŒ¨í„´)
    lstm_model = Sequential([
        LSTM(50, return_sequences=True),
        Dropout(0.2),
        LSTM(50),
        Dense(1)
    ])
    
    # ì•™ìƒë¸” ì˜ˆì¸¡
    prediction = 0.6 * arima_trend + 0.4 * lstm_model
    return prediction

# ê³„ì‚°ì‹
dubai_impact = (dubai_price_change / dubai_base_price) * 0.25 * fuel_sensitivity
```

#### 1.2 ì‹±ê°€í¬ë¥´ êµ­ì œì œí’ˆê°€ê²© (8% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Vector Autoregression (VAR) ëª¨ë¸
```python
# VAR ëª¨ë¸ (ë‹¤ë³€ëŸ‰ ì‹œê³„ì—´)
def singapore_product_model():
    # íœ˜ë°œìœ , ê²½ìœ , ì œíŠ¸ì—°ë£Œ ê°€ê²© ê°„ ìƒê´€ê´€ê³„ ëª¨ë¸ë§
    model = VAR(endog_data[['gasoline', 'diesel', 'jet_fuel']])
    results = model.fit(maxlags=7)
    forecast = results.forecast(steps=7)
    return forecast

# ê³„ì‚°ì‹
singapore_impact = (product_price_change / base_price) * 0.08 * regional_factor
```

#### 1.3 ì‹±ê°€í¬ë¥´ ì •ì œë§ˆì§„ (7% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Gaussian Process Regression
```python
# ê°€ìš°ì‹œì•ˆ í”„ë¡œì„¸ìŠ¤ íšŒê·€
def refinery_margin_model():
    kernel = RBF(length_scale=1.0) + WhiteKernel(noise_level=0.1)
    gp = GaussianProcessRegressor(kernel=kernel)
    gp.fit(X_train, y_train)
    prediction, std = gp.predict(X_test, return_std=True)
    return prediction, std

# ê³„ì‚°ì‹
margin_impact = (margin_change / historical_avg_margin) * 0.07 * volatility_factor
```

### 2. í™˜ìœ¨ ìš”ì¸ (15% ê°€ì¤‘ì¹˜)

#### 2.1 USD/KRW í™˜ìœ¨ (15% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: GARCH-LSTM ëª¨ë¸
```python
# GARCH-LSTM ë³€ë™ì„± ëª¨ë¸
def exchange_rate_model():
    # GARCH ëª¨ë¸ë¡œ ë³€ë™ì„± ì˜ˆì¸¡
    garch = arch_model(returns, vol='Garch', p=1, q=1)
    garch_result = garch.fit()
    volatility_forecast = garch_result.forecast(horizon=7)
    
    # LSTMìœ¼ë¡œ ê°€ê²© ì˜ˆì¸¡
    lstm = Sequential([
        LSTM(64, activation='tanh'),
        Dense(32, activation='relu'),
        Dense(1)
    ])
    
    return lstm_prediction * volatility_forecast

# ê³„ì‚°ì‹
exchange_impact = (usd_krw_change / base_rate) * 0.15 * oil_import_ratio
```

### 3. êµ­ë‚´ ì •ì±… ìš”ì¸ (20% ê°€ì¤‘ì¹˜)

#### 3.1 ìœ ë¥˜ì„¸ ì •ì±… (12% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Policy Change Detection + Rule-Based System
```python
# ì •ì±… ë³€í™” íƒì§€ ëª¨ë¸
def fuel_tax_model():
    # NLP ê¸°ë°˜ ì •ì±… ë³€í™” íƒì§€
    policy_changes = detect_policy_changes(news_data, policy_docs)
    
    # ë£° ê¸°ë°˜ ì˜í–¥ë„ ê³„ì‚°
    tax_impact = 0
    if policy_changes['tax_cut']:
        tax_impact = -policy_changes['cut_amount'] / current_price
    elif policy_changes['tax_increase']:
        tax_impact = policy_changes['increase_amount'] / current_price
    
    return tax_impact * 0.12

# ê³„ì‚°ì‹
tax_impact = (tax_change_amount / base_price) * 0.12 * policy_certainty
```

#### 3.2 ì›ìœ ìˆ˜ì…ë‹¨ê°€ CIFê¸°ì¤€ (8% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Multiple Linear Regression with Lasso Regularization
```python
# ì •ê·œí™”ëœ ë‹¤ì¤‘ì„ í˜•íšŒê·€
def import_price_model():
    features = ['dubai_oil', 'freight_cost', 'insurance', 'exchange_rate']
    model = Lasso(alpha=0.1)
    model.fit(X_train[features], y_train)
    prediction = model.predict(X_test)
    return prediction

# ê³„ì‚°ì‹
import_impact = (cif_price_change / base_cif) * 0.08 * import_dependency
```

### 4. êµ­ë‚´ ìˆ˜ê¸‰ ìš”ì¸ (15% ê°€ì¤‘ì¹˜)

#### 4.1 êµ­ë‚´ ì„ìœ ì¬ê³  (6% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Inventory Optimization + Prophet
```python
# Prophet ì‹œê³„ì—´ ì˜ˆì¸¡ + ì¬ê³  ìµœì í™”
def inventory_model():
    # Prophetìœ¼ë¡œ ê³„ì ˆì„± ê³ ë ¤
    model = Prophet(
        yearly_seasonality=True,
        weekly_seasonality=True,
        daily_seasonality=False
    )
    model.fit(inventory_df)
    forecast = model.predict(future_df)
    
    # ì¬ê³ -ê°€ê²© íƒ„ì„±ë„ ì ìš©
    elasticity = -0.15  # ì¬ê³  ì¦ê°€ ì‹œ ê°€ê²© í•˜ë½
    price_impact = elasticity * (forecast_inventory - normal_inventory) / normal_inventory
    
    return price_impact * 0.06

# ê³„ì‚°ì‹
inventory_impact = -0.15 * (current_inventory - avg_inventory) / avg_inventory * 0.06
```

#### 4.2 êµ­ë‚´ ì œí’ˆì†Œë¹„ëŸ‰ (5% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Seasonal ARIMA + External Regressors
```python
# SARIMAX ëª¨ë¸ (ê³„ì ˆì„± + ì™¸ë¶€ ë³€ìˆ˜)
def consumption_model():
    model = SARIMAX(
        consumption_data,
        exog=external_vars,  # GDP, ì˜¨ë„, íœ´ì¼ ë“±
        order=(2,1,2),
        seasonal_order=(1,1,1,12)
    )
    results = model.fit()
    forecast = results.forecast(steps=7, exog=future_exog)
    return forecast

# ê³„ì‚°ì‹
consumption_impact = (forecast_consumption - base_consumption) / base_consumption * 0.05
```

#### 4.3 ì§€ì—­ë³„ ì†Œë¹„ëŸ‰ (4% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Hierarchical Time Series + Spatial Analysis
```python
# ê³„ì¸µì  ì‹œê³„ì—´ + ê³µê°„ ë¶„ì„
def regional_consumption_model():
    # ì§€ì—­ ê°„ ê³µê°„ ìƒê´€ê´€ê³„ ëª¨ë¸ë§
    spatial_weights = calculate_spatial_weights(regions)
    
    # ê³„ì¸µì  ì˜ˆì¸¡ (ì „êµ­ â†’ ì§€ì—­)
    national_forecast = national_model.forecast(7)
    regional_forecasts = []
    
    for region in regions:
        regional_model = ARIMA(order=(1,1,1))
        regional_forecast = regional_model.forecast(7)
        
        # ê³µê°„ ì¡°ì •
        spatial_adjustment = np.dot(spatial_weights[region], neighbor_forecasts)
        adjusted_forecast = 0.7 * regional_forecast + 0.3 * spatial_adjustment
        
        regional_forecasts.append(adjusted_forecast)
    
    return regional_forecasts

# ê³„ì‚°ì‹
regional_impact = sum(region_weight[i] * region_change[i] for i in regions) * 0.04
```

### 5. ê²½ì œ ìš”ì¸ (7% ê°€ì¤‘ì¹˜)

#### 5.1 ì†Œë¹„ì ë¬¼ê°€ì§€ìˆ˜ (3% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Cointegration + Error Correction Model
```python
# ê³µì ë¶„ ë° ì˜¤ì°¨ìˆ˜ì • ëª¨ë¸
def cpi_model():
    # ê³µì ë¶„ ê´€ê³„ í™•ì¸
    coint_result = coint(oil_prices, cpi_data)
    
    if coint_result[1] < 0.05:  # ê³µì ë¶„ ì¡´ì¬
        # ì˜¤ì°¨ìˆ˜ì • ëª¨ë¸
        ecm = VECM(np.column_stack([oil_prices, cpi_data]), k_ar_diff=2)
        ecm_result = ecm.fit()
        forecast = ecm_result.predict(steps=7)
        return forecast
    else:
        # VAR ëª¨ë¸ë¡œ ëŒ€ì²´
        var_model = VAR(np.column_stack([oil_prices, cpi_data]))
        return var_model.fit().forecast(steps=7)

# ê³„ì‚°ì‹
cpi_impact = (cpi_change / base_cpi) * correlation_coefficient * 0.03
```

#### 5.2 ì „êµ­ ì§€ê°€ë³€ë™ë¥  (2% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Ridge Regression with Polynomial Features
```python
# ë‹¤í•­ íŠ¹ì„± íšŒê·€
def land_price_model():
    # ë‹¤í•­ íŠ¹ì„± ìƒì„±
    poly_features = PolynomialFeatures(degree=2)
    X_poly = poly_features.fit_transform(land_price_features)
    
    # Ridge íšŒê·€ë¡œ ê³¼ì í•© ë°©ì§€
    model = Ridge(alpha=1.0)
    model.fit(X_poly, oil_price_changes)
    
    prediction = model.predict(poly_features.transform(current_features))
    return prediction

# ê³„ì‚°ì‹
land_impact = polynomial_function(land_price_change, gdp_growth, interest_rate) * 0.02
```

#### 5.3 ì „êµ­ ìë™ì°¨ë“±ë¡í˜„í™© (2% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Logistic Growth Model + Trend Analysis
```python
# ë¡œì§€ìŠ¤í‹± ì„±ì¥ ëª¨ë¸
def vehicle_registration_model():
    # ë¡œì§€ìŠ¤í‹± ì„±ì¥ ê³¡ì„  í”¼íŒ…
    def logistic_growth(t, K, r, t0):
        return K / (1 + np.exp(-r * (t - t0)))
    
    popt, _ = curve_fit(logistic_growth, time_data, vehicle_data)
    K, r, t0 = popt
    
    # ë¯¸ë˜ ë“±ë¡ ëŒ€ìˆ˜ ì˜ˆì¸¡
    future_vehicles = logistic_growth(future_time, K, r, t0)
    
    # ì „ê¸°ì°¨ ë³´ê¸‰ë¥  ê³ ë ¤
    ev_penetration = predict_ev_penetration(future_time)
    fuel_demand_impact = -(ev_penetration * future_vehicles) / total_vehicles
    
    return fuel_demand_impact * 0.02

# ê³„ì‚°ì‹
vehicle_impact = (new_registrations - ev_registrations) / total_vehicles * elasticity * 0.02
```

### 6. ìœ í†µ ìš”ì¸ (3% ê°€ì¤‘ì¹˜)

#### 6.1 ì •ìœ ì‚¬-ëŒ€ë¦¬ì -ì£¼ìœ ì†Œ ë§ˆì§„ (2% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Game Theory + Nash Equilibrium
```python
# ê²Œì„ ì´ë¡  ê¸°ë°˜ ë§ˆì§„ ì˜ˆì¸¡
def retail_margin_model():
    # í”Œë ˆì´ì–´: ì •ìœ ì‚¬, ëŒ€ë¦¬ì , ì£¼ìœ ì†Œ
    players = ['refinery', 'distributor', 'gas_station']
    
    # ê° í”Œë ˆì´ì–´ì˜ ë¹„ìš© í•¨ìˆ˜
    cost_functions = {
        'refinery': lambda q: a1 * q**2 + b1 * q + c1,
        'distributor': lambda q: a2 * q**2 + b2 * q + c2,
        'gas_station': lambda q: a3 * q**2 + b3 * q + c3
    }
    
    # ë‚´ì‰¬ ê· í˜•ì  ê³„ì‚°
    equilibrium = solve_nash_equilibrium(cost_functions, demand_function)
    optimal_margins = calculate_margins(equilibrium)
    
    return optimal_margins

# ê³„ì‚°ì‹
margin_impact = (current_margin - equilibrium_margin) / base_margin * 0.02
```

#### 6.2 ë¬¼ë¥˜ë¹„ìš© ë° ìœ í†µë¹„ìš© (1% ê°€ì¤‘ì¹˜)
**AI ëª¨ë¸**: Transport Cost Optimization + Fuel Efficiency Analysis
```python
# ìš´ì†¡ë¹„ìš© ìµœì í™” ëª¨ë¸
def distribution_cost_model():
    # ìš´ì†¡ ë„¤íŠ¸ì›Œí¬ ê·¸ë˜í”„
    G = create_distribution_network()
    
    # ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜
    shortest_paths = {}
    for source in refineries:
        for destination in gas_stations:
            path = nx.shortest_path(G, source, destination, weight='cost')
            shortest_paths[(source, destination)] = path
    
    # ì´ ìš´ì†¡ë¹„ìš© ê³„ì‚°
    total_cost = 0
    for route, path in shortest_paths.items():
        distance = calculate_route_distance(path)
        fuel_cost = distance * fuel_efficiency * diesel_price
        driver_cost = distance * driver_rate
        total_cost += fuel_cost + driver_cost
    
    # ì¸í”Œë ˆì´ì…˜ ë° ìœ ê°€ ë³€ë™ ê³ ë ¤
    inflation_factor = predict_inflation()
    cost_forecast = total_cost * (1 + inflation_factor)
    
    return (cost_forecast - base_cost) / base_cost * 0.01

# ê³„ì‚°ì‹
distribution_impact = (transport_cost_change + storage_cost_change + labor_cost_change) / base_cost * 0.01
```

---

## ğŸ”„ ëª¨ë¸ í†µí•© ë° ì•™ìƒë¸”

### ì•™ìƒë¸” ê°€ì¤‘ì¹˜ ìµœì í™”
```python
# Bayesian Optimizationìœ¼ë¡œ ê°€ì¤‘ì¹˜ ìµœì í™”
def optimize_ensemble_weights():
    def objective(weights):
        # ê°€ì¤‘ì¹˜ ì •ê·œí™”
        normalized_weights = weights / np.sum(weights)
        
        # ì•™ìƒë¸” ì˜ˆì¸¡
        ensemble_pred = np.sum([
            w * model_pred for w, model_pred 
            in zip(normalized_weights, individual_predictions)
        ], axis=0)
        
        # ê²€ì¦ ë°ì´í„°ë¡œ ì„±ëŠ¥ í‰ê°€
        mape = mean_absolute_percentage_error(y_true, ensemble_pred)
        return mape
    
    # Bayesian Optimization
    optimizer = BayesianOptimization(
        f=objective,
        pbounds={(f'weight_{i}': (0.01, 1.0) for i in range(15))},
        random_state=42
    )
    
    optimizer.maximize(init_points=10, n_iter=50)
    optimal_weights = optimizer.max['params']
    
    return optimal_weights
```

### ìµœì¢… ì˜ˆì¸¡ ê³„ì‚°
```python
def generate_final_forecast():
    # 15ê°œ ëª¨ë¸ì˜ ê°œë³„ ì˜ˆì¸¡
    predictions = {
        'dubai_oil': dubai_oil_price_model(),
        'singapore_product': singapore_product_model(),
        'refinery_margin': refinery_margin_model(),
        'exchange_rate': exchange_rate_model(),
        'fuel_tax': fuel_tax_model(),
        'import_price': import_price_model(),
        'inventory': inventory_model(),
        'consumption': consumption_model(),
        'regional_consumption': regional_consumption_model(),
        'cpi': cpi_model(),
        'land_price': land_price_model(),
        'vehicle_registration': vehicle_registration_model(),
        'retail_margin': retail_margin_model(),
        'distribution_cost': distribution_cost_model()
    }
    
    # ê°€ì¤‘ì¹˜ ì ìš©
    weights = load_optimal_weights()
    
    # ìµœì¢… ì˜ˆì¸¡ ê³„ì‚°
    final_prediction = sum(
        weights[factor] * prediction 
        for factor, prediction in predictions.items()
    )
    
    # ë¶ˆí™•ì‹¤ì„± ì •ëŸ‰í™”
    prediction_intervals = calculate_prediction_intervals(
        predictions, weights, confidence_level=0.95
    )
    
    return {
        'point_forecast': final_prediction,
        'lower_bound': prediction_intervals['lower'],
        'upper_bound': prediction_intervals['upper'],
        'confidence_level': 0.95
    }
```

---

## ğŸ“Š ì„±ê³¼ í‰ê°€ ì§€í‘œ

### ì •í™•ë„ ì§€í‘œ
- **MAPE** (Mean Absolute Percentage Error): < 3%
- **RMSE** (Root Mean Square Error): < 50ì›
- **MAE** (Mean Absolute Error): < 30ì›
- **ë°©í–¥ì„± ì •í™•ë„**: > 85%

### ë¹„ì¦ˆë‹ˆìŠ¤ ì§€í‘œ
- **ì‚¬ìš©ì ë§Œì¡±ë„**: > 4.5/5.0
- **API ì‘ë‹µ ì‹œê°„**: < 200ms
- **ì‹œìŠ¤í…œ ê°€ìš©ì„±**: > 99.9%
- **ì˜ˆì¸¡ ì—…ë°ì´íŠ¸ ì£¼ê¸°**: ì‹¤ì‹œê°„ (ë§¤ì‹œê°„)

### ëª¨ë¸ ì‹ ë¢°ì„± ì§€í‘œ
- **ë°±í…ŒìŠ¤íŒ… ì„±ëŠ¥**: ê³¼ê±° 2ë…„ ë°ì´í„° ê¸°ì¤€ > 90% ì •í™•ë„
- **êµì°¨ ê²€ì¦ ì ìˆ˜**: 5-fold CV > 0.85
- **íŠ¹ì„± ì¤‘ìš”ë„ ì•ˆì •ì„±**: ìƒìœ„ 5ê°œ ìš”ì¸ ì¼ê´€ì„± > 95%
- **ì˜ˆì¸¡ êµ¬ê°„ ì ì¤‘ë¥ **: 95% ì‹ ë¢°êµ¬ê°„ ì‹¤ì œ ì ì¤‘ë¥  > 93%

---

## ğŸš€ ë°°í¬ ë° ìš´ì˜

### CI/CD íŒŒì´í”„ë¼ì¸
```yaml
# .github/workflows/deploy.yml
name: Oil Price Forecast Deploy
on:
  push:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install dependencies
        run: pip install -r requirements.txt
      
      - name: Run model tests
        run: pytest tests/model_tests.py
      
      - name: Deploy to production
        run: |
          docker build -t oil-forecast .
          docker push $ECR_REGISTRY/oil-forecast:latest
```

### ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼
- **ëª¨ë¸ ë“œë¦¬í”„íŠ¸ ê°ì§€**: ë§¤ì¼ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
- **ë°ì´í„° í’ˆì§ˆ ê²€ì‚¬**: ì‹¤ì‹œê°„ ì´ìƒì¹˜ íƒì§€
- **API ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: Prometheus + Grafana
- **ì¥ì•  ì•Œë¦¼**: Slack/ì´ë©”ì¼ ìë™ ì•Œë¦¼

ì´ ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œì„ í†µí•´ 15ê°œ ë³€ë™ ìš”ì¸ì„ ì¢…í•©ì ìœ¼ë¡œ ë¶„ì„í•˜ì—¬ ì •í™•í•˜ê³  ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ìœ ê°€ ì˜ˆì¸¡ ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.